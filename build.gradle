plugins {
    // Provide convenience executables for trying out the examples.
    id 'application'
    // ASSUMES GRADLE 5.6 OR HIGHER. Use plugin version 0.8.10 with earlier gradle versions
    id 'com.google.protobuf' version '0.8.18'
    // Generate IntelliJ IDEA's .idea & .iml project files
    id 'idea'
    id "scabbard.gradle" version "0.5.0"
}

repositories {
    maven { // The google mirror is less flaky than mavenCentral()
        url "https://maven-central.storage-download.googleapis.com/maven2/" }
    mavenCentral()
    mavenLocal()
}

configurations.all {
    resolutionStrategy.eachDependency {
        if (requested.group == "com.github.kittinunf.result" && requested.name == "result" && requested.version == "3.0.0") {
            useVersion("3.0.1")
            because("Transitive dependency of Scabbard, currently not available on mavenCentral()")
        }
    }
}

apply plugin: 'java'

compileJava {
    // This only works when forking and passing 'javac' as an executable
    options.compilerArgs << '-Adagger.fullBindingGraphValidation=ERROR'
}


sourceCompatibility = 1.8
targetCompatibility = 1.8

// IMPORTANT: You probably want the non-SNAPSHOT version of gRPC. Make sure you
// are looking at a tagged version of the example and not "master"!

def argsVersion = '2.33'
def autoServiceVersion = '1.0.1'
def autoValueVersion = '1.9'
def daggerVersion = '2.41'
def grpcVersion = '1.45.0'
def protobufVersion = '3.19.2'
def protocVersion = protobufVersion

dependencies {
    implementation "io.grpc:grpc-protobuf:${grpcVersion}"
    implementation "io.grpc:grpc-stub:${grpcVersion}"
    compileOnly "org.apache.tomcat:annotations-api:6.0.53"

    // Use 'api' rather than 'compile' for Android or java-library projects.
    compileOnly         "com.google.auto.value:auto-value-annotations:${autoValueVersion}"
    annotationProcessor "com.google.auto.value:auto-value:${autoValueVersion}"

    implementation "com.google.dagger:dagger:${daggerVersion}"
    annotationProcessor "com.google.dagger:dagger-compiler:${daggerVersion}"

    // This is used for dagger spi.
    annotationProcessor project(':AnnotationProcessor')
    compileOnly project(':AnnotationProcessor')

    implementation "com.google.dagger:dagger-producers:${daggerVersion}"

    implementation "com.google.dagger:dagger-grpc-server:${daggerVersion}"
    annotationProcessor "com.google.dagger:dagger-grpc-server-processor:${daggerVersion}"

    implementation group: 'args4j',    name: 'args4j',         version: "${argsVersion}"
    implementation group: 'args4j',    name: 'args4j-site',    version: "${argsVersion}"

    // examples/advanced need this for JsonFormat
    implementation "com.google.protobuf:protobuf-java-util:${protobufVersion}"

    implementation "io.grpc:grpc-netty:${grpcVersion}"
    runtimeOnly "io.grpc:grpc-netty-shaded:${grpcVersion}"

    testImplementation "io.grpc:grpc-testing:${grpcVersion}"
    testImplementation "junit:junit:4.12"
    testImplementation "org.mockito:mockito-core:3.4.0"

    // This gives a UI at
    implementation 'io.perfmark:perfmark-api:0.25.0'
    // Only needed for applications, not libraries.
    implementation 'io.perfmark:perfmark-traceviewer:0.25.0'
}

protobuf {
    protoc { artifact = "com.google.protobuf:protoc:${protocVersion}" }
    plugins {
        grpc { artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}" }
    }
    generateProtoTasks {
        all()*.plugins { grpc {} }
    }
}

scabbard {
    // enable to get graphs of dependencies - will be slow.
    enabled false
    outputFormat "svg"
}

// Inform IDEs like IntelliJ IDEA, Eclipse or NetBeans about the generated code.
sourceSets {
    main {
        java {
            srcDirs 'build/generated/source/proto/main/grpc'
            srcDirs 'build/generated/source/proto/main/java'
        }
    }
}

startScripts.enabled = false

task kvProgTopLevelServer(type: CreateStartScripts) {
    mainClass = 'kvprog.toplevelserver.ServerApp'
    applicationName = 'top-level-server'
    outputDir = new File(project.buildDir, 'tmp/scripts/' + name)
    classpath = startScripts.classpath
}

task kvProgBServer(type: CreateStartScripts) {
    mainClass = 'kvprog.bserver.ServerApp'
    applicationName = 'b-server'
    outputDir = new File(project.buildDir, 'tmp/scripts/' + name)
    classpath = startScripts.classpath
}

task kvProgCServer(type: CreateStartScripts) {
    mainClass = 'kvprog.cserver.ServerApp'
    applicationName = 'c-server'
    outputDir = new File(project.buildDir, 'tmp/scripts/' + name)
    classpath = startScripts.classpath
}

task kvProgClient(type: CreateStartScripts) {
    mainClass = 'kvprog.client.ClientApp'
    applicationName = 'client'
    outputDir = new File(project.buildDir, 'tmp/scripts/' + name)
    classpath = startScripts.classpath
}

applicationDistribution.into('bin') {
    from(kvProgTopLevelServer)
    from(kvProgBServer)
    from(kvProgCServer)
    from(kvProgClient)
    fileMode = 0755
}

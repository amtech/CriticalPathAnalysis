syntax = "proto3";

option java_multiple_files = true;
option java_package = "kvprog";

package kvprog;

service KvStore {
  // Store KV.
  rpc Put (PutRequest) returns (PutReply) {}
  // Get existing KV.
  rpc Get (GetRequest) returns (GetReply) {}
  // Metadata about calls seen.
  rpc Calls (CallsRequest) returns (CallsReply) {}
}

message PutRequest {
  string key = 1;
  string value = 2;
}

message PutReply {
  enum Status {
    SUCCESS = 0;   // Operation succeeded
    NOTFOUND = 1;  // Key was not found
    SYSTEMERR = 2; // Some kind of system error occurred
  };

  Status status = 1;
}

message GetRequest {
  string key = 1;
}

message GetReply {
  enum Status {
    NOTFOUND = 0;   // Key was not found
    SYSTEMERR = 1; // Some kind of system error occurred
  };

  oneof ValOrStatus {
    string value = 1;
    Status failure = 2;
  }
}

message CallsRequest {
}

message CallsReply {
  repeated CallInfo call_info = 1;
  // Each RPC & Producer Node contributes a path element, which includes a name & duration.
  // TODO: This currently is the full execution graph, but we may only want a single Critical Path
  // which can be modeled linearly.
  repeated PathElement path_element = 2;
}

message CallInfo {
  string call_type = 1;
  int64 count = 2;
}

// An element of the critical path.
// For example:
// @Produces
// ListenableFuture<Out> produceOut() {
//   Request request = generateRequest();
//   return getOutService.send(request);
// }
// produceOut# will be one PathElement, with a sub_element of getOutService.
// The duration of this element will be the generateRequest# computation, and
// the latency of the RPC call will show up in the sub_element.
message PathElement {
  // Name of this PathElement.
  optional string id = 3;

  // Duration of this PathElement, in micros.
  optional int64 duration_micros = 1;

  // Child elements on the path.
  repeated PathElement sub_elements = 2;
}
